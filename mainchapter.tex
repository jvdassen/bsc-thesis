\chapter{Design}\label{design}
This Chapter describes the design decisions taken for the implementation of the Bazo Wallet. Section \ref{designguide} introduces design guidelines that were given from the start of the project. Section \ref{transactioninfo} and the following subsections explain how the required functionality of the Wallet was designed.
\section{Design Guidelines}\label{designguide}
For the development of the Bazo Wallet, multiple requirements were explored with the financial service provider. These are described in \ref{functionalreq}. This section introduces several design guidelines which were known from the start of the project and consequences on other design desicions.
\subsection{Progressive Web Applications}
The Bazo Wallet is supposed to be designed as a Progressive Web Application. Due to Progressive Web Applications having native elements, PWA's can be a solution for providing a unified experience for multiple operating systems, targeting both mobile and desktop devices. This implies that a web application is to be crafted, that supports all the functional requirements described in \ref{functionalreq}. The Web application therefore needs to contain the following pages to support the core requirements:
\begin{itemize}
\item Page to share transaction data
\item Page to send new transactions
\item Page to inspect account state
\item Page to request new funds from bonus points
\end{itemize}

\subsection{Network Communication and Interfaces}\label{networkandinterfaces}
Since the Application is designed as a PWA and a quality requirement is the fully client side approach for all the operations, all operations need to be made in the browser. Since no backend application should be leveraged, the Web app needs to be able to sign transactions in the browser. All further communication with the Bazo network needs to be done over web interfaces. This led to the design of a RESTful web interface for the Bazo light client, which was then implemented. The following operations should be supported by the API:
\begin{itemize}
\item Querying account state

This endpoint should return all necessary information about the account's state such as balance, the transaction counter and information if the account has root access.
\item Preparing transactions

By supplying fee, transaction value, target and source address to this endpoint, the API will prepare the transaction hash and return it to the client to calculate the signature.
\item Distributing transactions in the peer-to-peer network

This endpoint can be used to post a transaction hash and signature. The API will then distribute the transaction in the peer-to-peer network.
\end{itemize}
In order to depict the complete payment process for users in the role of a merchant, the application needs to retrieve infromation such as transaction value through a web interface. Further, an interface to the existing bonus program was designed in partnership with the company. The following operations were designed to be implemented into the backend of the financial service provider:
\begin{itemize}
\item Filing a new request to deduct bonus points and credit a Bazo account
\item Querying the state of filed requests
\item Querying the transaction value of a POS instance given a supplied ID denoting the POS system in proximity.
\end{itemize}
\subsection{Device Sharing}
In order to explore how suitable a PWA approach for the implementation of a Wallet or payment application is, the application is required to share transaction data on a device-to-device basis. Technologies such as NFC and Bluetooth should be evaluated for their browser support and implemented. 
The data model and mechanism designed to use the described technologies are explained in the consecutive sections.
%??%
\section{Transaction Information} \label{transactioninfo}
One requirement, that is that Bazo coins can be exchanged between users without direct involvement or administration from the service provider was incorporated into the core design of the Bazo currency. To fulfill said requirement it is vital that transaction information, can be exchanged between users of the Bazo Wallet. This section outlines the design of the data model and mechanisms in order to share said information between web applications.
%Search for papers, resources etc.
%%Sharing transaction information in native applications is often achieved with technologies such as NFC, Bluetooth or by encoding and reading transaction information from a Quick-Response Code.
\subsection{Schema}\label{schema}
In order to communicate Bazo Transactions to other devices and applications, an URI Scheme was designed to hold transaction information, so that a requesting party can communicate it. The grammar and structure for the schema closely follows the Bitcoin Improvement Proposal 21 (BIP 21) for an URI scheme since it contained all necessary elements to fulfill the requirement \cite{bip21}. The URI Schema consists of a required part which holds the protocol name and the recipient's fully qualified Bazo address. The structure and schema of an example transaction request are visible in \ref{fig:urischeme}.

\[
\underbrace{\overbrace{bazo:}^{\mathrm{protocol}}\overbrace{34ad8...8a4a4}^{\mathrm{public\ key}}}_{\mathrm{required\ components}}
\underbrace{\overbrace{?amount=123}^{\mathrm{amoun t}}\overbrace{?label=1 Coffee}^{\mathrm{label}}\overbrace{?message=Message}^{\mathrm{message}}}_{\mathrm{optional\ components}}
\]\label{fig:urischeme} Example of a transaction request with the Bazo Wallet.

% reference nfc bridge
The chosen data model implies that the Bazo Wallet and other applications that need to interact with it need to be able to encode and decode transaction information as supplied in the described grammar.
This enables to encode complete transaction information as well as a an URI to the application page into a medium such as a QR-Code. With this, a convenient way of transferring transaction data is given.
Since merchants frequently have more advanced payment systems and don't want to encode payment information into media such as QR-Codes for each new transaction, the payment page of the Wallet also needs to be able to accept additional parameters, by which the Wallet can then query the transaction value from a service.
Figure \ref{schema} shows an URI consting of the endpoint of the payment page, together with additional parameters that can be supplied to have the payment page filled with transaction information upon opening it. This procedure is further described in Figure \ref{networkandinterfaces}.
\[
\underbrace{\overbrace{https://host/:}^{\mathrm{Host}}\overbrace{\#/auth/user/send}^{\mathrm{payment\ page}}}_{\mathrm{required\ components}}
\underbrace{\overbrace{posid=<ID>}^{\mathrm{POS\  identification}}\overbrace{?paymentinfo=bazo:<public key>}^{\mathrm{transaction\ data}}}_{\mathrm{optional\ components}}
\]\label{fig:schema}Example of a complete URI pointing to the payment page and containing a valid transaction request.

%reference impl

\subsection{Device Sharing}\label{pocnfcbridge}
In order to explore further possibilities on how to extend the browser support for native API's a Proof of Concept was designed. The PoC is targeted to the android Platform, since NFC support is still fairly limited on iOS devices at the time of the design. This means that with Core NFC, a technology by Apple, only communication with passive NFC Tags is supported \cite{corenfc}. The PoC, further referenced as 'NFC Bridge', should run as a background service and enable two processes.
\begin{enumerate}
\item Reading NFC devices:
The application should be registered as a handler for NFC messages. If an NFC message is read from another NFC device such as another active device or an NFC Tag, the user is prompted with applications that can handle the data format. If the user selects the NFC Bridge application, the data received from the NFC Adapter should be parsed and the user prompted with the Payment page of the Bazo Wallet. The payment page is then prefilled with the payment information extracted from the NDEF message.
\item Pushing to NFC devices: The NFC Bridge application should allow the web-based Bazo Wallet to handover encoded transaction information which can then be pushed to NFC devices.
The first design sketch included that communication between the Bridge application and the Bazo Wallet is done through an HTTP or Websocket. This implied that the NFC Bridge would need to run as a background service, listening for incoming push requests.
Since the android platform allows starting an application when a certain type of data is received through the configuration of application intents, this design was preferred. That way, it is also possible to start the android application from the browser and pass the transaction data to it. The application does not need to run when doing so, and the effort to maintain a server in the application is omitted.
\end{enumerate}

\subsection{Merchant options}\label{merchantoptions}
In order to completely support the payment process, which does require interaction of the application with backend services from the financial service provider, interfaces need to be integrated into the application.
This is also necessary since some platform do not support WebNFC in the browser, which means that the payment process can not be carried out in a complete device-to-device manner. On iOS devices, support for NFC is restricted to native API's and the functionality is limited to reading passive NFC Tags.
In order to enable the complete payment process, the mechanism that is being implemented can be described as follows. The user of an iOS device can use any existing NFC Tag Reader application from the Apple App Store. Before the payment process can be started, the merchant needs to supply payment information in form of a correct Bazo address as well as some token that represents the Point-of-sale system. The merchant should have the possibility to write these informations to the NFC Tag at the POS, using the Mobile Wallet application on android.
Once this set up is in place, the user will approach the POS System and may start the payment process. The cashier will scan the items, and the POS System will automatically associate the POS ID with the transaction value. The user can now use any existing iOS or android application to read the NFC tag. Since the transaction information is encoded in a URI, the user is taken to the payment page of the Mobile Wallet. Here, the POS ID is used to query the transaction value associated with the POS from a web-service. Since the Bazo Address is supplied in the URI as well, the transaction request is complete and can be confirmed by the user. Once confirmed the Mobile Wallet will sign the transaction and send it to the Bazo network. Figure
\ref{fig:POS} shows the process of transferring transaction information and transaction issueing under the constraint that a third party service needs to be queried.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{diagrams/POS_flow.png}
\caption{\label{fig:POS}Payment process using an NFC tag with static transaction data.}
\end{figure}

\subsection{Onboarding Process and Account Generation}\label{onboarding}



\chapter{Implementation}
Chapter \ref{design} introduced the design of the Bazo Wallet in order to fulfill the requirements to such an application documented in Chapter \ref{requirements}. This Chapter documents the implementation phase of the application. Chapter  \ref{architecture} outlines the architecture, the application employed. The following sections explain how the individual functional requirements were implemented.
\section{Architecture\label{architecture}}
The application was implemented as a Progressive Web Application. The characteristics of a progressive web application have been outlined in Chapter \ref{pwacharacteristics}. The application was implemented as a web application with the addition of the following items to comply as a progressive web application:
\begin{itemize}
\item Manifest
A manifest is a JSON file that describes metadata of a web application such as links to icons for different screen sizes. It is further used to configure the progressive web application. For example, the name that will be displayed in the app drawer on the phone once the app is installed, can be set here. It is important to note that only Google Chrome on Android supports manifest files. \cite{manifest} Other platforms, such as iOS rely on meta tags in the main html file of the web application \cite{applemetatags}. Implementing meta tags and manifest was straight forward, the names and description of the application had to be given, and the static ressources such as icons had to be linked correctly.
\item Service worker and Offline Capability
A service worker is a method to enable background processing of certain actions. A common way how service workers are used is to enable offline capability by intercepting web requests. By caching static parts of the web application, offline availability is enabled \cite{serviceworkers}. The service worker used in the project is automatically generated at compile time by a webpack plugin. This makes it possible to flexibly configure the service worker and define all the static resources which are then cached for offline usage. The offline experience is further enhanced by an event listener, which is integrated in the routing of the SPA. If a user is on a page that requires network access, the application will then inform the user about the network loss and redirect to the Home page.

\item Security Constraints
User-agents such as Google Chrome pose certain security constraints to allow a web application to be installable. This restricts web application and all cross-origin requests to be in a secure context, such as secured http or websockets \cite{manifest}, \cite{securitychrome}.
\end{itemize}

\subsection{User Interface}\label{userinterface}
The application was implemented as a Single-Page-Application. With SPAs, it is possible to structure content and application interface into pages without leaving the document. %find sources%, 
This deals with the quality requirement, that the application should run in the browser with as little logic on the backend as possible. The Wallet was structured into the following pages, each accessible through a unique URI, although all technically in the same document:
\begin{itemize}
\item \textbf{Home Page}
This is where the user will be directed upon loading the application. If a user tries to access a page, he is not allowed to, he will be directed to this page. For example, if a user opens the link to the payment page of the application, but the network connection is lost, he will be temporarily be redirected to the home page until network access becomes available again.
\item \textbf{Settings Page}
On this page, the user can edit configurations such as showing or hiding advanced options on the other pages, which are directed at users in the role of a merchant. This would mean that the user has an additional field available to encode the POS ID into the transaction data. Further, the user is given the possibility to set the URI of a Bazo client web interface, that is then used for further communication with the client's web interface.
\item \textbf{Accounts Page}
Whenever a user tries to access any of the other pages except for the Home and Settings Page, without an account being stored in the browser, he will be redirected to the accounts page. Here, it is possible to store new Bazo accounts, by supplying the public key and a name to identify the account. Every public key can only be stored once, so that the total balance can be computed from the set of accounts. All accounts stored in the browser are displayed in a table, along with information such as balance, name and address for every account. Each of the stored accounts can be inspected in the Bazo Block Explorer, see \ref{bazoblockexplorer} and deleted from the storage. An account can also be selected to be the main account used. This account will then automatically get preselected for all other operations on other pages.
This page can also be opened with an address supplied in the URI, which would then be filled into the form. This is employed to make the process of inviting the user into the system easier.
\item \textbf{Requesting Funds Page}
When a user wants to share transaction data with another user, he would use this page. Here the user can set the necessary information such as target address and transaction value. If the user has selected advanced options in the Settings Page, he may set an identifier for a POS system. 
The compiled transaction data can then be transferred to other users using as many of the transaction sharing methods, as supported by his device and browser. Only the sharing methods supported by the underlying platform are visible to the user, in order to progressively enhance the application. For each of the transfer methods, an overlay would be opened to instruct the transfer process and to indicate the state of the transfer.
\item \textbf{Sending Funds Page}
If a user opens transaction data which is encoded into a single URI, he would be taken to the Sending Funds Page.
All transaction data supplied as parameters in the URI are then parsed and filled into the form. If a POS id is present, see \ref{transactioninfo}, the transaction value is looked up. All of these informations can also be manually supplied by filling out the form. In either cases, the user needs to select an account from which he wants to deduct the transaction, given that multiple accounts are stored. For said source account, the maximal amount of coins to be spent is displayed on the page. If the transaction data is valid, the user can request the transaction to be initiated. Once the transaction is prepared, a modal is opened, where the user needs to enter his private key, which is used to sign the transaction. The process of preparing, signing and submitting a transactoin is further described in \ref{blockchaininteraction}.
\item \textbf{Obtaining new funds}
This page allows users to inspect and submit new requests to deduct value from the bonus program and to top up a supplied Bazo account.
The user interface consists of table, where previous fund requests are displayed along with their state, and a form to submit new requests. In order to make a new request, the user needs to supply their token, target Bazo address and the amount of coins he wants to receive. 
\end{itemize}
The described pages are always a standalone display, where it is not possible for a user to be on multiple pages. However, there are parts of the User Interface that are shown on all of the pages. These parts along with the individual pages were logically structured into reusable components:
\begin{itemize}
\item \textbf{Navigation Bar}
The navigation bar, which is located at the top of the screen holds multiple items. The icon of the project, a display of the total balance over all accounts and the currently selected main account are displayed. 
On devices which are less than 550 pixels wide, the total balance and main account are hidden.
\item \textbf{Side Bar}
The side bar is located at the right side of the document and can be used to navigate between the individual pages. If there is no account configured in the application, only the Settings and Account pages are shown. If there is no network access, navigating between pages is restricted to the Home, Settings, Accounts and Requesting Funds pages.
The sidebar also contains a display of the total amount of balances over all accounts and the icon of the project. Users can select between German and English languages at the bottom of the Sidebar. Each text in the application is fully internationalized in these two languages.


\item \textbf{Offline status display}
There is a background service, which is constantly checking if the application has network access. If this is not the case, the usage of the application is restricted to the Home, Settings, Accounts and Requesting Funds pages. If a user happens to be on any other page during connection loss, he is taken to the Home page where the Offline status display is shown. If the user does not navigate further he will be taken back to the original page, once network connection is obtained again.
\item \textbf{Progress Bar}
On each of the pages there is a thin progress bar at the very top of the document, above the header. This progress bar is used to indicate the progress of network requests made after the application is loaded.

\end{itemize}

Since the User Interface of the coinblesk-frontend application was structured as a SPA with reusable components, it was possible to use this application as a base \cite{coinbleskfrontend}. Since that application was designed as a client-server application, most of the logic had to be rewritten. However, it was possible to inherit the application structure as well as certain components. The Home Page as well as the four components that are visible on all pages were reused. Few modifications such as styling had to be applied. Almost all individual pages had to be rewritten. When doing this, the same User Interface Framework was used, since it provided reusable components and a consistent look with other parts of the application. A webpack configuration was used to optimize and build the application.

\subsection{Storage and State management\label{storageandstate}}
In Chapter \ref{qualityrequirements}, the requirement for complete client-side operation and security requirements were introduced. This implied, that a storage solution local to the browser had to be used. HTML5 Web Storage is a browser side storage solution, that is supported by the majority of browsers \cite{localstoragetest} \cite{localstorage}.
%part?%
In the Security part of the specification document, multiple issues with the security of Web Storage are explained \cite{localstorage}.
With a new API for browser side encryption in discussion by the World Wide Web Consortium, mechanisms like symmetrically encrypting values in the storage could be leveraged. However, the API is only considered a Recommendation of the Consortium\cite{webcrypto}.
This makes local storage of security related data such as private keys unsuitable. Therefore, only user-data such as settings and public keys of Bazo accounts were stored in the Web Storage. For explicit state management vuex, a library for state management with Vue.js was used \cite{vuex}. The subset of state that needed to be persisted in Web Storage was placed in this storage.
%??%
\subsection{Network Communication}
Multiple operations of the Bazo Wallet are performed using cross-origin http requests. These operations include payment preparation, payment submission and account balance querying. All of these operations are centralized in a single Service module, that can be shared between the individual components. With this it is possible to parametrize network requests globally. This is a requirement, so that the URI used to perform the requests can be configured by the user. The actual communication with the endpoints of the Bazo client and their semantics are explained in \ref{blockchaininteraction}.

\section{Transaction Sharing}
Requesting payments is a core requirement for the Bazo Wallet to qualify as a payment system for end-users. The design of the sharing process and the data model were explained in \ref{transactioninfo} This section explains how sharing transaction data across devices was implemented.
\subsection{Web APIs and Browser Support}\label{browsersupport}
At the time of writing, more and more native API's are made available for the Web.
However, the API specification for NFC connectivity in the browser is still in draft \cite{webnfc}. Partial implementations of the API are available in Google Chrome on android devices. Other user-agents and platforms do not yet support the feature although some have expressed intent to implement. The implementation state in Google Chrome is not documented thoroughly since there exists no implementation report yet, as they are available for other specifications \cite{localstoragetest}\cite{webnfc}. This implied that the specification and Google Chrome's source code was the only way to obtain information on the subject apart from testing.
% TODO Reference state for Webkit, moz, IE.
For the prototype, the feature was implemented for Google Chrome on android.
In order to allow web-nfc in Google Chrome, there need to be two flags set to enable the experimental implementation: \textit{Experimental Web Platform features} and \textit{webnfc}. The first of these flags will show the nfc object in the navigator object of the browser. However, this does not mean that the hardware does support web-nfc. The latter flag can only be set on devices whose hardware actually supports NFC. This approach of hiding functionalities behind flags to let developers test the implementations, are called origin trials, in the Chromium Projects \cite{origintrials}.
After extensive testing, it became clear that the current implementation of Google Chrome only allows devices to use NFC functionalities such as reading and writing to NFC tags as a target. Performing these actions to active NFC devices such as a smartphone will throw the corresponding error according to the specification draft \cite{webnfc}. After discussion with members on the working group, they confirmed that targeting active NFC devices is not yet implemented. The reason for this is that these operations would require native UI elements from the android operating system. However, they expressed intent on implementing it in the future \cite{webnfcpeer}.

Another challenge posed the creation and signing of Bazo transactions in the browser. The structure of a Funds Transaction can be seen in figure \ref{fig:FundsTX}. Since not all data-types that are usually available in C-like structs, are available in the browser, a bridging solution had to be implemented. The application was therefore designed as a signing-only client, with the implication of designing a web interface into the light client as described in \ref{networkandinterfaces}. This is a common approach when building web based Wallets that don't store the users private key on a server \cite{bitcoinclients}\cite{masteringbitcoin}.

\begin{algorithm}
\caption{FundsTx}
\label{euclid}
\begin{algorithmic}[1]
\State type FundsTx struct $\{$
\State     Header byte
\State Amount uint64
\State Fee uint64
\State TxCnt uint32
\State From [32] byte
\State To [32] byte
\State Sig [64] byte
\State  $\};$
\end{algorithmic}
\end{algorithm}\label{fig:FundsTX}Structure of a FundsTx in Bazo \cite{lisg}.

%%\begin{figure}
%%\centering
%%\includegraphics[width=1\textwidth]{diagrams/AccountTx_struct.png}
%%\caption{\label{fig:FundsTX}Structure of a FundsTx in Bazo \cite{lisg}.}
%%\end{figure}

\subsection{Web NFC}
In section \ref{pocnfcbridge} the semantics of the data model of a transaction that can be shared among users in the form of a single URI was explained.

NFC also enables devices to share information at a distance that is less than 10 centimeters. Users can share business cards, make transactions, access information from a smart poster or provide credentials for access control systems with a simple touch.
NFC, is a technology standard that allows contactless, two-way data transfers between devices that are within centimeters of distance \cite{nfcforum}.
Since the support for WebNFC is limited to android devices, the functionality for writing and reading the transaction data is visible only to the users that have activated advanced options.
The corresponding UI elements are therefore hidden if the user has not activated advanced options. The same goes for browsers and devices that lack webnfc or nfc support.
Using the API for the actual read and write operations was straightforward since the API consists of one method for each of them. The data type of the NFC record was set to URL.
This way the URI can be read from all types of devices. Android devices can therefore use the android system or the Bazo Wallet to scan the Tag. If the android system is used, the tag can be placed to the back of the device. If NFC is activated in the system settings and the user has unlocked the phone, the NFC record is parsed. Since the data type of the NFC record is a single URI, android's intent system is used to ask the user which application to use for the URI. This should include Google Chrome for all standard installations and the Bazo Wallet itself, if it is installed to the homescreen.


\subsection{NFC Bridge}\label{nfcbridge}
Due to limited browser support for Native API's such as webNFC, see \ref{browsersupport}, a prototype was discussed and implemented in the scope of this thesis. The prototype involved a native android application that should enable the web application to forward transaction information that could be forwarded to NFC capable devices using the Android Beam technology.
The design and requirements of such an application was outlined in \ref{pocnfcbridge} and the two main functional requirements for the application were presented.
Reading NFC messages from passive and active devices, was achieved without implementing it in the android application. This was done by changing the data model for transaction information to one that can be expressed in a single URI. With this media type, it is possible to use the tag dispatching system in android. This would work as follows:
\begin{enumerate}
\item An NDEF message is received when the android device is unlocked and NFC enabled.
\item The NDEF message for this application contains just a signle URI. Through android's intent system the application that fits best is started.
\item If the Bazo Wallet PWA was previously installed on the android device, an intent filter is present for the origin URI of the PWA. This will result in the PWA being opened with all transaction data passed as parameter.
\item If the Bazo Wallet PWA is not installed there will be no intent filter requesting the data. The user is then prompted with all applications that can handle an URI, such as a Web browser. If a browser is selected, then the Bazo payment page is opened with all transaction data passed as a parameter.
\end{enumerate}

%https://developer.android.com/guide/topics/connectivity/nfc/nfc.html

Writing the transaction data to other android devices was implemented using the Android Beam technology.
The transaction data can be passed to the NFC Bridge by either manually entering it into a form or by passing it as data through an intent. Passing data to the application through parameters has the benefit that web applications can generate links that will take the user to the application. Such a link can contain further data, which would be set to the transaction data the user wants to share with another android device.
If the android phone is held against another Android Beam enabled device, the NFC Bridge application will automatically set the appropriate transaction data encoded as an NDEF message and push it to the other device.

At the time of writing, NFC support for iOS platforms was just released for their most recent publicly available version, iOS 11. The NFC functionality offered to iOS developers covered writing and reading to NFC tags on the iPhone 7 and iPhone 7 Plus \cite{corenfc}. Thus, an NFC Bridge application similar to how it was developed for android would not extend the functionality of existing generic NFC applications. The NFC fallback capabilities with the Bazo Wallet on iOS are outlined in Chapter \ref{fallback}.
\subsection{Bluetooth Low Energy}\label{ble}
Bluetooth Low Energy, allows for devices to exchange data in short wireless connection. Devices will usually establish connections in a peer-to-peer topology \cite{blep2p}. Data can be structured into GATT-services which is then exposed to other BLE-capable devices. These devices may then perform actions such as reading and writing on these Services \cite{blegatt}. 
This makes the web-bluetooth API useful for web applications interacting with BLE-devices in proximity. However, to use the API for transaction sharing between two web pages on different devices, this would imply for one of the devices to take on the role of a server. This functionality is not provided in the web-bluetooth API, and makes it therefore not suitable to solve the requirement \cite{webble}. 
%%This was confirmed by \cite{undefined}.

Since the web-bluetooth API could not be used for data sharing, the websharing API was leveraged to provide easy sharing capabilites with low friction. Low friction for usage is given through the deep integration of the API with android's intent system. By invoking the API through passing the relevant URI, all sharing options available to the device will be presented to the user \cite{webshareapi}. This has two advantages:
\begin{enumerate}
\item Technologies such as Bluetooth, E-mail, SMS and even Android Beam are always available, even on system without installed third-party applications.
\item Sharing transaction data is not limited to functionalities provided by the Wallet. The user has the possibility to use any existing application, for example, his favorite chat applicatoin, to transfer the URI. When new applications are installed, they are automatically registerend and then considered by the android's intent system for sharing.
\end{enumerate}

The Web Share API is not considered a W3C standard, however it was assessed as an origin trial in Google Chrome on Android and is now normally available starting with version 61 \cite{webshareapi}\cite{websharespec}.


\subsection{Quick Response Codes}\label{qrcodes}
Quick Response Codes were initially envisioned to be the fallback way to transfer transaction data for devices that either do not support NFC or in cases where the browser does not support webNFC. With the data model explained in \ref{schema}, all transaction data can be placed in a QR Code in the form of a single URI.
This data model was chosen with the intent to support devices where the browser does not allow camera access in the browser over the webRTC API, which is still not widely adapted by browsers \cite{webrtcimplreport}. Testing Google Chrome and Safari on desktop and mobile systems showed that only Google Chrome has implemented the webRTC API for camera access. Safari has  implemented webRTC into their most recent version 11, which was released to the public in September 2017  \cite{safari11release}\cite{ios11release}. This implies that users with older versions of iOS will not have access to the API. Users with such a device can still read the QR Code using a generic native application. Since all information is encoded in a single URI the payment page can be opened with all necessary information prefilled.
Google Chrome has already implemented the webRTC API, therefore multiple QR Reader libraries leveraging the API exist.
The QR Scanner from the coinblesk-frontend project was a simple wrapper around an existing QR Reader library \cite{instascan}. Due to the implementations in Safari version 11, the underlying library had to be modified so that certain attributes were set. This allowed to run the QR Reader in the Browser of iOS devices. The actual decoding of the image with the library is implemented in pure JavaScript. This has performance drawbacks, since there is no hardware support. Further, the library is quite large with around 1.5 MB size for a minified JavaScript file. Because of this, the ShapeDetectionAPI was evaluated, which promises certain optimizations, since the decoding is not run in JavaScript \cite{shapeapinotes}. However, this new API is neither a W3c Standard or on track of becoming one \cite{shapeapispec}.

\subsection{Fallback Solutions}\label{fallback}
Subsections of Chapter 4.2 outlined how existing native and web-enabled API's were leveraged for the Bazo Wallet to share transaction data. This section documents the fallback solutions that were evaluated for devices or platforms that lack the support for the API, either natively or on the web.
For android, the complete functionality of NFC could be leveraged. Writing and reading NFC tags was implemented with the web-nfc API. Complete peer to peer communication was enabled by developing an API bridge, see \ref{nfcbridge}. A similar functionality is also provided by the webshareAPI implemented for Bluetooth transferrals \ref{ble}.
As iOS platforms only support native API's when communicating over NFC and peer to peer mode is not yet included, the fallback solution to use NFC on iOS consists of using a native application. Writing the NFC tag can be done with any generic NFC application or, on an android device, with the Bazo Wallet itself.
Initially a QR-Code was envisioned to be the fallback solution that should cover all devices. However, reading a camera video stream is only possible for the most recent version of iOS. This implies that this can not be used as a fallback solution for older iOS devices, although the same procedure as with NFC, where an existing native application can be used for scanning is possible.
Because of this limitation in iOS, a solution where the URI with all transaction data is being copied to the users clipboard was implemented for both systems. This way, iOS users have a convenient way of obtaining the URI and can then manually distribute the URI over their preferred channel. The same functionality is offered to android users over the webshare API which has a better integration into the android system, so that the URI is directly passed to the androids intent system for sharing, see \ref{ble}.

\section{Blockchain Interaction}\label{blockchaininteraction}
Actual network communication with the Bazo network in a trustless way posed the most difficult technical challenge for the application. The following operations and issues had to be evaluated:

\begin{enumerate}
\item Building the transaction data in the schema defined in the Bazo protocol. \ref{fig:FundsTX}.
Due to technical limitations of the browser, this application context is not suitable to fulfill the requirements of a light client implementation. Reasons for this are lack of support for tcp communcation, appropriate storage solutions and data structures.

\item Signing the transaction data with the appropriate algorithms.
\item Verifying transaction and account information.
In order to run the Bazo Wallet as trustless as possible, the application has to maintain at least a certain amount of the blockchain to verify information. For the Bazo Wallet this would mean that the Bazo Wallet itself needs to verify blocks and transactions, or that the Bazo Wallet needs to communicate with a trustworthy Bazo client. 
\end{enumerate}
% link to gomobile, link to evaluation & future work


\subsection{Bazo Client Web interface} \label{bazoclientwebinterface}
In order to interact with the Bazo Client, a web interface had to be created. The web service was designed as a RESTful API and implemented into the light client.
The web service consisted of two endpoints for each type of transaction in the Bazo currency and one for the retrieval of account information such as balance and other parameters.
For each of the transaction types the following two endpoints need to be used.
\begin{itemize}
\item The endpoint at /create<Account Type>/ is used to create and obtain a transaction hash given all parameters for the Transaction struct are sent. This solves the problem of lacking the appropriate data types in the browser. The  returned transaction hash can then be signed on the client.
\item The endpoint at /send<Account Type>/ accepts the transaction signature, which was generated on the client, and matching transaction hash. With these informations, the transaction can be considered complete, so that the underlying Bazo client can distribute the transaction for further validation in the network. The web service does not validate the transaction and respond the answer to the client.
\end{itemize}  

\subsection{Transaction Signing}\label{transactionsigning}
Due to limitations of the browser for C-like structures as they would be required to create a FundsTx, an interface had to the Bazo client was to be developed. 
The process of obtaining transaction information, requesting a new transaction, signing and dispatching it into the network is shown in figure \ref{fig:TransactionProcess}. The process can be described as follows:
\begin{enumerate}
\item The application queries the necessary account information to request a transaction struct in a later step. This is a necessary step, since the TxCount of the transaction has to be correct in order for the transaction to be valid.
\item When the account information is read, the web application can send a request to the web service to create a new FundsTx struct. The Bazo client creates the appropriate structure, hashes it using the SHA3-256 algorithm and returns it to the Wallet.
\item The Wallet is now in charge of asking the user about its private key, signing the received transaction hash and sending it to the Bazo client.
\end{enumerate}

This approach is comparable to the mechanism employed in the official JavaScript API of the Ripple currency \cite{ripplelib}.
Figure \ref{fig:ripplesendTx} demonstrates how a transaction can be sent with the Ripple cryptocurrency using the official library. The mechanism can be outlined as follows:
\begin{enumerate}
\item A connection to an interface is opened over a Websocket. 
\item A request is made to obtain relevant data and instruction for the payment.
\item The data returned from preparing the transaction is signed.
\item The API submits the signed Transaction over the WebSocket.
\end{enumerate}


Comparing the mechanism in Bazo, see Figure \ref{fig:TransactionProcess}, and Ripple, \ref{fig:ripplesendTx}, reveals certain differences, although the approach, with the respective consequences being similar.
\begin{itemize}
\item \textbf{Protocol mechanism} In Ripple, there exists a convenient method to prepare all data into a single JSON object, that needs to be signed and submitted. This step is splitted up into multiple steps in the web interface for Bazo. The client is responsible for querying the account information and then requesting a transaction hash from said information.
\item \textbf{Connection Type} Both cryptocurrencies use web interfaces for communication with a node in the Network. In Bazo http is used, while the Ripple library makes use of a WebSocket for two-way communication. Given that two-way communication is not necessary for the Bazo currency, the http approach was chosen, since this is supported by a broad range of devices and browsers.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{diagrams/transactionProcess.png}
\caption{\label{fig:TransactionProcess}Requesting, building, signing and submitting payment information in Bazo.}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{diagrams/ripplelibSendTX.png}
\caption{\label{fig:ripplesendTx}Programmatically creating, signing and sending a transaction with Ripple-lib \cite{ripplelib}.}
\end{figure}


\subsection{Client Integration}\label{bazomobile}

Chapter \ref{bazoclientwebinterface} explained the interaction between the Bazo Wallet and the Bazo light client over a web interface.
This Chapter explains contexts in which the Bazo client can be run, consequences and documents the efforts of porting the light client to mobile devices.
Due to the security constraints one needs to consider when interacting with cross-origin resources in a PWA, the Bazo client web interface has to be in a secure context \cite{securitychrome}. This would mean that an SSL certificate needs to be installed or that the server needs to accessible through a secure reverse tunnel.
This makes mobile devices as a runtime difficult. However, a proof of concept was developed to show that mobile devices are technically feasible to run the client. 

To overcome these limitations, native application wrappers for the light client written in Go were evaluated. 

The first approach for porting the light client, which was written in the \textit{Go language}, evaluated the usage of go bindings for java. These could then be used in a native Android application. There exists a project \textit{go mobile}, that can be used to generate bindings from a package written in \textit{Go}. However, the current state of the go mobile project did not support all networking and data structure needs to fulfill the requirement. Further, this would have required to restructure the go application as a package \cite{gobind}. Programming to such bindings usually has the advantage, that the Java application can directly call methods of the binded package. Since all communication between the actual Wallet application would go over the http interface, this would not pose an advantage.
The second approach focused on cross-compiling the Bazo client for the android operating system running on ARMv5 architectures.
To port the complete Bazo client without any modifications to the android operating system the application was compiled using the clang compiler. The compiler can be obtained through androids official NDK or it can be compiled from scratch. The complete toolchain was compiled targeting the arm architecture, and android API version 21 for a darwin x64bit system which was the host for the compilation \cite{standalonetoolchain}. The clang compiler of the toolchain was then used to configure the go environment for cross-compilation. This involved configuring the golang environment for arm architectures and to use the freshly compiled clang compiler \cite{gobuild}.
The binary was then copied to an android device an ran in the scope of an existing application. This is a necessary step for binaries that are run on devices were root access is not given. The application performed well, so that ngrok was used to create a secure reverse tunnel. With this in place the web application was able to interact with the Bazo client running on the same device but accessible through the secure context. Detailed instructions for installation can be found in \ref{bazoandroid}.
This Proof of Concept could be leveraged to create an actual android application wrapping the binary. However, a solution to configure SSL appropriately would need to be found.
% reference in future work

\section{Optimizations and Testing}
In order to assess and optimize the quality of the developed web application, Lighthouse was used for the audit. \begin{quote}
Lighthouse is an open-source, automated tool for improving the quality of web pages.
\end{quote}. 
There exist various workflows to run the tool, however, running it directly from the Google Chrome Developer Tools seemed the easiest. The audit can be performed against almost any web page, and assesses five key factors of web applications, such as \textit{Progressive Web App}, \textit{Performance}, \textit{Accessibility}, \textit{Best Practices} and \textit{SEO}. For each of the metrics, several audits are performed and then summarized to express the scoring as a percentage. It is possible to drill down and obtain detailed information on a failed audit. For some of the audits, the tool can even predict possible enhancements \cite{lighthouse}.
Running the tool against the deployed web application showed the strengths and weaknesses of the implementation. Initially, the application got the full score for \textit{Progressive Web App} and \textit{Accessibility}, which performs audits against the Progressive Web Application Checklist \cite{pwachecklist}. The biggest optimization potential was highlighted through the \textit{Performance} metric, which got a result of 44. There were various issues that hindered the performance of the application. These issues and their solution are explained in the following.
\begin{itemize}
\item Render-blocking scripts:

The JavaScript library that contained the decoder for QR-Codes, makes up a large part of the application's size. Loading the library from the start of the application had a negative impact on the loading time required until the application is drawn and interactive. This is an interesting fact, since the development of the Shape Detection API, introduced in \ref{qrcodes}, has the intention of avoiding the necessity to include a decoding library in the application. This issue was solved by dynamically loading the library, once the user enters the actual page where the decoding capability is needed.
\item Large images:

Images that are not properly sized, can also increase the loading time, thus affecting when the application becomes interactive. The images, supplied by the Design agency were compressed, resized and converted to a more suitable format to decrease the loading and rendering time. By doing so, the size of the assets was decreased by around 80\%.

\item Rendering time:

The time required to render the home page was further optimized by making use of a server-side rendering approach. Since the home page contains mostly static content, it was ideal for this technique. Server-side rendering was achieved by incorporating an optimization plugin into the \textit{webpack}-based build process.
\end{itemize}
The issues described above, led to initial loading times of around five to seven seconds until the application becomes responsive. It is important to note, that Lighthouse performs these tests under constrained settings. Network speeds are throttled to resemble mobile devices and caching is not leveraged. This testing environment is comparable to a mobile device with a slow network connection accessing the application for the first time. With the performance optimizations described above, the initial loading time was decreased under two seconds. Subsequent loading times would take around 250ms until the application becomes responsive, by leveraging the caching mechanisms.
After optimizing the application, the \textit{Performance} metric received a score of 77.

For the full score of the \textit{Best Practises} metric, the application would have to be deployed to a server that allows serving over HTTP/2. Since this is not part of the actual implementation of the web application and rather a question of deployment, this metric can not be improved with the code basis of the web application.

\begin{bclogo}[logo=\bcattention, couleurBarre=red, noborder=true, 
               couleur=LightSalmon]{Important!}
This section is incomplete. The content on testing is missing.
\end{bclogo}
\newpage
